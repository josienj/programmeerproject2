##Report Programmeerproject
Josien Jansen<br>
11162295<br>
Universiteit van Amsterdam<br>
23-06-2016
###Beschrijving:
Social Train Journey is een app gebaseerd op gezellig samen reizen in de trein. De gebruiker dient in te loggen met zijn Facebookaccount en de Facebookvrienden die de app ook gebruiken zijn ook zichtbaar in de app. Vervolgens kan de gebruiker zoeken op zijn vertrekstation en krijgt de gebruiker alle vertrekkende treinen van minstens het komende uur terug. De gebruiker kan klikken op de trein waar hij straks in zit, en daarbij officieel ‘inchecken’. Een gebruiker kan maar in één trein tegelijk ingecheckt zijn; de gebruiker zit immers ook maar in één trein tegelijk. 
Nadat de gebruiker ingecheckt heeft in een vertrekkende trein, komt de gebruiker bij het scherm waarbij de Facebookvrienden die de app ook gebruiken te zien zijn. Door op de ‘Check of het een Social Train Journey wordt’-button te klikken, krijgt de gebruiker te zien of hij/zij met Facebookvrienden in de trein zit. Wanneer de Facebookvrienden in dezelfde trein zitten, kan er sociale interactie komen door op de Facebook Messengerbutton te klikken en daarbij automatisch een plaatje te versturen waarbij het logo van de app staat en de tekst: “We zitten in dezelfde trein!”. Tevens kan de gebruiker uitchecken door het vinkje van ‘Ingecheckt in trein’ uit te zetten. Met dit vinkje kun je ook gelijk checken of je wel of niet ingecheckt bent in een trein.
Buiten dit worden alle check-ins van de gebruiker opgeslagen in een lokale SQLiteDatabase, deze check-ins zijn te zien in Historie. Verder is er een mogelijkheid om uit te loggen met het Facebookaccount en dan start de gebruiker weer bij het beginscherm waarbij ingelogd moet worden met Facebook. 

![screenshot1](https://cloud.githubusercontent.com/assets/18394953/16310740/0ce25ce8-396e-11e6-8795-f54946868e31.png)
![screenshot2](https://cloud.githubusercontent.com/assets/18394953/16310741/0ce346e4-396e-11e6-9441-14bd35fd810f.png)

###Technical Design:
Als er teruggekeken wordt op het oorspronkelijke idee van de app, is er een heleboel veranderd. Van tevoren is niet goed nagedacht over hoe dingen te implementeren binnen de app. Onder andere het toevoegen van een online database was er niet in het oorspronkelijke design, terwijl dit wel cruciaal is voor de app. De structuur is nu als volgt:
 ![design new](https://cloud.githubusercontent.com/assets/18394953/16310780/3ade4472-396e-11e6-987c-979eb42470dc.png)
De indeling van de grafiek is als volgt: de blauwe kleur betekent dat het activities zijn, waarbij de gebruiker altijd moet starten bij de Facebook login. De **FBLoginActivity** haalt het openbare profiel van de gebruiker op, evenals de vriendenlijst van de gebruiker. Dit wordt ondersteund door de **FacebookSdk**, die de login zelf regelt. Elke login via Facebook wordt gelijk opgeslagen als user in de **online App42 database**. Als de gebruiker eenmaal heeft ingelogd, zal dit automatisch gecheckt worden wanneer de app opnieuw geopend wordt en gelijk doorgaan naar **MainActivity**. Zo hoeft de gebruiker dus niet elke keer onnodig in te loggen met Facebook. In MainActivity kan de gebruiker zoeken op het vertrekstation waar van hij/zij reist. Deze Activity wordt ondersteund door een **HttpRequestHelper**, die logischerwijze het request van de gebruiker ondersteunt, en een **TrainAsyncTask** die waarbij de request afgehandeld wordt, de XML geparsed wordt en doorgegeven wordt aan een **TrainAdapter** waardoor de ListView gevuld wordt met de juiste data. Vervolgens kan er op een item van de ListView geklikt worden en gaat de gebruiker door naar het volgende scherm: **CheckInActivity**. Dit scherm is enkel te bereiken na het klikken op een ListView, omdat dit echt de check-in van een trein waarop de gebruiker geklikt heeft aangaat. De gebruiker kan ervoor kiezen om uit dit scherm te gaan door op de ingebouwde terug-knop te klikken, waarbij de gebruiker terugkomt in de lijst met vertrekkende treinen, de gebruiker kan ook via het Navigation menu naar een andere Activity gaan. De bedoeling is in principe gewoon dat de gebruiker op de ‘Incheck’-button klikt. Dan wordt de eigen Facebook-naam, evenals de Facebookvrienden die de app ook gebruiken en het ritnummer van de trein opgeslagen in App42. Dit gebeurt in JSON-format omdat dit de syntax van App42 ondersteunt.  De gebruiker wordt dan naar het  **FriendsActivity-scherm geleidt**. Daar staat een overzicht van alle Facebookvrienden die de app ook gebruiken, tevens kan de gebruiker zijn eigen status zien (ingecheckt of niet) bij de Checkbox. De Checkbox is tevens de enige mogelijkheid om weer uit te checken bij een trein. Bij het uitchecken wordt jouw check-in verwijderd uit de online database. Het is ook niet mogelijk om voor een tweede trein in te checken als je nog ingecheckt bent, dit om onjuiste informatie naar Facebookvrienden te voorkomen. Dit zal de Checkbox zelf ook aangeven door middel van Toasts/Alert Dialogs. 
Om de status van iets bij te houden werk ik tot drie keer toe met booleans die opgeslagen worden in **Shared Preferences**. Dit omdat het hoofdzakelijk gaat om het doorgeven van informatie in verschillende activities. Door middel van Shared Preferences kan de meest up-to-date informatie in elke activity opgehaald worden.
<br>Het gaat om de volgende gevallen:<br>
#####-Checkbox: 
de boolean staat standaard op false, wat betekent dat de gebruiker niet ingelogd is. Elke keer als de FriendsActivity opnieuw wordt aangeroepen, wordt de status van deze boolean opnieuw bekeken. De boolean staat dus standaard op false, en kan op true gezet worden als er een check gedaan wordt of er items van de huidige gebruiker in de database zitten. Als deze er niet zijn, betekent dit dat de gebruiker niet ingecheckt is, en kan de boolean false blijven. Als er wel wat gevonden wordt, is er dus een check-in gevonden van de gebruiker en zal de boolean true worden en het vinkje zichtbaar. Wanneer de gebruiker op de Checkbox klikt terwijl deze aangevinkt is, zal de gebruiker een alert dialog krijgen met de vraag of hij/zij echt wil uitchecken. Als de gebruiker echt wil uitchecken, zal alle data die gevonden wordt van die gebruiker verwijderd worden en de boolean weer op false. 
#####-Inchecken: 
Hierbij gaat het om het feit dat een gebruiker maar in één trein tegelijk zit en daarom ook maar één check-in tegelijk kan hebben. Dit wordt als volgt bijgehouden: de boolean staat standaard op true, wat inhoudt dat de gebruiker kan inchecken in een trein. Wanneer er op de check-in button geklikt wordt, zal de boolean op false gezet worden. Dit betekent dat de gebruiker niet nog een keer kan inloggen voordat de boolean op true staat. De boolean zal weer op true gezet worden nadat er geklikt is op uitchecken, de data in de database verwijderd wordt en de gebruiker dus weer opnieuw mag inchecken in een trein. 
#####-Zelfde trein: 
De check of Facebookvrienden bij elkaar in dezelfde trein zitten, wordt ook door middel van een boolean gecheckt terwijl wat met deze check te maken heeft in één dezelfde Activity gebeurd. Toch is hiervoor gekozen omdat binnen de uiteindelijke if-statement waarbij de check tussen facebookvrienden en het ritnummer wordt gedaan, er in de Thread gewerkt wordt en niet in de User Interface. Dit betekent dat er niks mogelijk is van een Toast of Alert-Dialog. Daarom werk ik daar ook met een boolean die standaard op false staat, als de gebruiker in dezelfde trein zit en in de betreffende if-statement terecht komt, wordt de boolean door middel van Shared Preferences op true gezet. De boolean zonder Shared Preferences op true zetten was wederom niet mogelijk, omdat er vanuit de thread niks opgehaald kan worden. Daarna kan bij de method ‘check’ de boolean opgehaald worden en aan de hand daarvan een alert-dialog geshowd worden.  
<br>De check of Facebookvrienden bij elkaar in de trein zitten wordt als volgt gedaan in de method parsedata: alle items in de App42 database worden geparsed, daarna wordt er voor elke gebruiker de vriendenlijst bekeken, wanneer de vriendenlijst en de gebruiker bij elkaar voorkomen (het dus vrienden zijn), kijk dan naar het ritnummer en of deze overeenkomt, wanneer het overeenkomst verandert de boolean dus in true. De refresh-knop in FriendsActivity is er om de volgende situatie te voorkomen: een gebruiker checkt in bij een trein, checkt of er Facebookvrienden van hem/haar in dezelfde trein zitten, wat niet het geval is. Vijf minuten later checkt een Facebookvriend wel in bij dezelfde trein, deze gebruiker ziet gelijk dat hij/zij bij een Facebookvriend in de trein zit. Echter, de andere gebruiker zal zijn pagina eerst moeten refreshen om dit te zien; dit zal ook als informatie bij de app-omschrijving staan. Om het de gebruiker makkelijk te maken zodat hij/zij niet eerst naar een andere Activity hoeft te gaan om vervolgens deze Activity weer opnieuw aan te klikken, zorgt de refresh-knop ervoor dat de pagina vernieuwd wordt met de up-to-date informatie.  Wanneer Facebookvrienden bij elkaar in de trein zitten, is het mogelijk om sociale interactie te creëren door op het logo van Facebook Messenger te klikken. Hierbij wordt er automatisch een plaatje met  het logo van Social Train Journey en de tekst ‘We zitten in dezelfde trein’ meegestuurd. De gebruiker kan ook zelf tekst toevoegen aan het bericht, waardoor het gemakkelijk is om contact te leggen met de Facebookvriend die je dan kunt opzoeken in de trein. Er gebeurt dus een hoop in FriendsActivity, helaas is dit ook terug te zien in de code. Hier had wellicht een helpersclass handig geweest, maar door tijdsnood is dit niet verwezenlijkt. 
<br><br>
Verder kan de gebruiker nog afzonderlijk naar **HistoryActivity gaan**, waar alle check-ins van de gebruiker worden laten zien. Dit is gewoon een nice-to-have feature zodat de gebruiker in een overzicht ziet in welke treinen hij zit en rond welke tijdstippen. De gebruiker kan deze items ook afzonderlijk van elkaar verwijderen. Deze Activity wordt ondersteund door een **DBhelper-class**, die de SQLiteDatabase bijhoudt en aanmaakt.  Verder wordt de data gedefined in de helpersclass **History**. De volgende dingen worden daar in opgeslagen:
<br>
- id<br>
- vertrektijd<br>
- eindbestemming<br><br>
Deze worden in de SQLiteDatabase gezet nadat de check-in button is aangeklikt. Het specifieke item vanuit MainActivity wordt eerst al doorgegeven aan CheckInActivity, en vervolgens vanuit CheckInActivity in de Historie gezet. 
Als laatste kan de gebruiker bij de **SettingsActivity** uitloggen van de app door middel van uitloggen met het Facebook-account. Ook hier komt eerst een Alert Dialog om te checken of de gebruiker echt wil uitchecken. Wanneer de gebruiker op ‘Ja’ klikt, zal er vanuit de FacebookSdk een logout plaatsvinden. De gebruiker start weer bij het hoofdscherm en de app kan weer van voor af aan beginnen. De data in de online database en in de SQLiteDatabase blijven overigens gewoon opgeslagen nadat de app uitgelogd is. 


###Challenges
De vier projectweken zijn zeer intense weken geweest voor mij. De eerste vier dagen heb ik mij gericht op het maken van een Bierlijst-app. Na dit qua Design uitgewerkt te hebben, leek het mij ten eerste niet erg leuk, en ten tweede geen fijn werk met een ontzettend grote online database. Dit heeft mij doen overstappen naar de Social Train Journey app; er moest dus al gelijk een boel ingehaald worden. Het weekend daarop heb ik nagedacht over het Design van de app, maar hier heb ik helemaal niet goed over nagedacht helaas. Pas in week 3 bijvoorbeeld besefte ik mij dat er wel degelijk een online database nodig is om vergelijkingen tussen de acties van verschillende Facebookgebruikers te kunnen vinden. Week 1 heb ik dus in ieder geval het besluit genomen om te switchen naar een volledig andere app. Week 2 heb ik mij (te lang) bezig gehouden met het parsen van de NS-API. De NS geeft data terug in XML en omdat de tutorials mij niet erg duidelijk werden over XML, en ik veel las over een ‘handige’ json-lib waarbij het erg eenvoudig zou moeten zijn om van een XML-bestand een JSON-bestand te maken. Ik had wel al eerder JSON geparsed en snapte dit ook volledig, dus ik besloot voor deze optie te gaan. Helaas heeft dit mij niet veel verder geholpen, zelfs juist achteruit. Ik ben letterlijk de hele week bezig geweest met het juist ontvangen van de NS-data en dit in een ListView weer te geven. Op vrijdag was ik eindelijk zo ver dat het XML correct geparsed werd, maar toen werkte de ListView en de Adapter nog niet mee. Ik heb dat weekend hard gewerkt en zondag was het eindelijk zo ver dat de data perfect in de ListView werd geshowt. Doordat het parsen van de data met erg veel tegenslagen ging, heb ik besloten om de Stationlijst niet te parsen om verschillende redenen:
<br>
- De stationslijst bevat per station vier verschillende namen, waarbij je eigenlijk alleen de afkorting nodig hebt maar dat snapt de gebruiker niet. Met de stationsnaam kom je niet ver omdat bijvoorbeeld Amsterdam Centraal een httprequest heeft van /station=asd.
<br>
- Het is niet fijn voor de gebruiker als elke keer als hij/zij op een station zoekt, dit even duurt voordat het station gevonden is. Verder is het ook nog maar de vraag hoe dat dan met AutoCompleteTextView werkt, wat ik geïmplementeerd heb.
<br> 
- Stations veranderen niet erg vaak, het is in ieder geval bij te houden met de hand. Daarom is ervoor gekozen om de stations allemaal in een string-array te zetten, met als eerste de afkorting en daarna het treinstation. Deze keuze is weer gemaakt omdat je ook van de TextView geen toString kunt maken als er enkel Amsterdam Centraal staat. Nu wordt enkel het eerste woord (dus de afkorting) achter de http-request geplakt en is er altijd een geldige invoer als er voor een AutoCompleteTextView is gekozen door de user.  Ik snap dat dit voor de user niet ideaal is, maar gezien het grote tijds-constraint vond ik dit een van de minder belangrijke zaken om perfect te hebben. 
<br><br>
Dan waren we bij week 3, de week waarin ik spontaan besloot om een SQLiteDatabase te maken voor de historie. Later zag ik dat ik de Historie als additional feature had beschreven, maar evengoed leuk om te hebben. Het implementeren hiervan ging gelukkig zonder al te veel problemen. Daarna werd de Facebookkoppeling toch wel erg belangrijk; zonder dat is de app nog niks waard. In deze week kwam ik er dus ook achter dat ik niet goed nagedacht had over hoe deze koppeling gemaakt moest worden. De SQLiteDatabase is alleen lokaal, dus kan er nog niks vergeleken worden. Al gauw vond ik in ieder geval een tutorial die uitlegde hoe je de Facebookvrienden die de app ook gebruiken kan ophalen; dit lukte al redelijk snel en daarmee kon je in ieder geval Facebookvrienden vinden. Nu de koppeling met ritnummer nog. Hiervoor vond ik na wat zoekwerk de online databases App42 Cloud API; erg geschikt voor mijn app en het bevatte tevens een speciale feature dat er met Facebookaccounts ingelogd kan worden. Flink uitzoeken hoe het werkte en na een tijdje kon elke Facebookgebruiker die zich aanmeldt voor de app in de online database gestored worden. Toen was het nog van belang dat het ritnummer ook online opgeslagen wordt. Veel bekeken en geprobeerd, uiteindelijk slaat App42 de eigen facebooknaam op, alle namen van je vrienden die de app ook gebruiken, en je ritnummer. Daarna moet dit correct geparsed worden om de koppeling te kunnen maken. Dit werd helaas ook pas in week4. Dit is nogal complexe code geworden, en had een stuk mooier gekund. Echter, de tijd speelt een grote rol en ik heb jammer genoeg geen tijd gehad om deze te herschrijven. Daarna kwam ik erachter dat er toch eigenlijk nog wel veel bugs in zaten, zoals:
<br><br>
- Je kunt oneindig inchecken, waardoor het totaal niet hoeft te kloppen met welke Facebookvrienden je in de trein zit
<br>
- Je kunt niet uitchecken, waardoor je ook altijd in die trein blijft
<br>
- Je moet de pagina verlaten en weer opnieuw aanklikken om de nieuwste data te krijgen, als een Facebookvriend dus NA jou incheckt, moet je dit eerst gedaan hebben wil je kunnen zien dat je in dezelfde trein zit. 
<br><br>
Flink wat problemen dus, en allemaal gefixt in week 4. Er is nu mogelijkheid tot uitchecken, er kan maar één check-in tegelijk openstaan, en er wordt automatisch gerefresht of anders is er een refresh button waarbij je gemakkelijk de nieuwste data binnenkrijgt. Daarna moest de code nog worden herzien en helaas is er dus weinig tijd geweest om de code netjes in verschillende classes te zetten, maar ik heb op dat moment gekozen voor een volledige app met dus gehele MVP en twee additional features  in plaats van een mooie, duidelijke code. Ik hoop dat deze overweging juist genomen is. Als ik namelijk al die extra bugs niet gefixt zou hebben, is de app alsnog waardeloos en nu is het echt een volledige app (uiteraard nog met ruimte voor verbetering, maar globaal werkt de app volledig).
<br><br>Kortom, ontzettend veel leermomenten! In het kort:
<br>
- Beter nadenken over opzet app, niet zomaar ergens aan beginnen
<br>
- Niet teveel tijd besteden aan één ding, hierdoor ben ik erg in tijdnood gekomen met de essentiele zaken van de app
<br> 
- Het werken met FacebookSdk (login, store friends, connect met Facebook Messenger)
<br>
- Het werken met een lokale SQLiteDatabase
<br>
- Het werken met basic authorization van een API
<br>
- Het parsen van XML en het correct laten zien in de ListView en doorgeven aan nieuwe Activities. 
<br>
- Het werken met SharedPreferences (misschien zelfs onnodig vaak gebruikt?)
<br>
- Het werken met online Database App42
<br>
- Het storen van stringS in JSON-documentatie
<br>
- Het ophalen van JSON-documenten
<br>
- Geleerd dat de manier waarop ik programmeer ontzettend chaotisch is (vaak snap ik mijn eigen code de volgende dag niet meer), dus leermoment voor de volgende keer is dat ik vanaf het begin met meer classes moet gaan werken om later niet het overzicht kwijt te raken
<br>
- Meer comments plaatsen vanaf het begin
<br>
- Het werken aan een individueel project en zelf volledig verantwoordelijk zijn
Ik denk dat ik van het programmeerproject echt de essentie van programmeren heb geleerd. Daarbij vind ik het jammer dat ik pas zo laat voor elkaar heb gekregen dat de app werkend is zodat er weinig  tijd is geweest voor de finishing-touch. 

###DEFENSE
De beslissingen die ik heb gemaakt om juist wel of juist niet te doen, zijn allemaal doorgrond met redenen. De reden waarom mijn code qua design niet optimaal is, is omdat ik een volledig werkende app continu voor liet gaan. Met alles wat ik schreef dacht ik: ‘Misschien gaat dit helemaal niet werken, dus waarom zou ik het nu al heel mooi en efficiënt gaan maken, het moet eerst maar eens werken.’ Dan duurde het helaas langer dan gepland en als het eenmaal werkte, wilde ik gelijk door met het volgende onderdeel omdat de klok blijft tikken. Helaas heb ik eigenlijk pas één dag van tevoren qua volledigheid een werkende app kunnen afleveren, waardoor er bijzonder weinig tijd is voor een flinke code-refresh. Correctness telt zwaarder dan design in mijn ogen, en ook in de ogen van de beoordelingen van de afgelopen vakken. Zeker scope is het belangrijkste en ik heb tot aan de laatste dag proberen te zorgen dat mijn scope optimaal is: in mijn ogen heb ik niet meer kunnen doen dan wat ik nu afgeleverd heb. Als er meer tijd zou zijn, zou ik mijn Layout mooier maken, wellicht een aparte Activity voor de Checkout en het implementeren van push-berichten als de user in dezelfde trein als een Facebookvriend zit. Verder is het design-gedeelte ook een erg belangrijk punt; hier zijn nog veel verbeteringen op te maken. Ik zou dan bijvoorbeeld een aparte App42 HelpersClass maken waarbij alles waarin App42 wordt aangeroepen daar apart in gedeclared staat. Dit zouden de Activities een stuk rustiger en duidelijker maken.  Ook een aparte FBhelper zou beter zijn, dan staat alles met Facebook ook niet lukraak door de code heen. Ik zou ook de minder mooie string-array van stations veranderen en ervoor zorgen dat wanneer een gebruiker op ‘Amsterdam Centraal’ klikt, en alsnog gezocht wordt op http://webservices.ns.nl/ns-api-avt?station=asd, dus dat de afkortingen binnen het AutoCompleteTextView weg zijn. Er is dus zeker ruimte voor verbetering als de tijd dit zou toelaten. Verder heb ik veel keuzes van waarom ik dingen in mijn app heb gedaan al vermeld bij Challenge. 
